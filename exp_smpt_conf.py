# Script R5.2: SMT Confirmation of DFI Additive Inverse Multiplicity - Final
# Mathematical Obligation: R5 from math LLM's refined deliverables.
# This SMT script aims to show:
# 1. Existence of multiple distinct DFI inverses for DFI a (a_val >= 2) when Ω >= 3.
# 2. Absence of multiple distinct DFI inverses for DFI a (a_val = 1) when Ω = 2 or Ω = 5.

from pysmt.shortcuts import (Symbol, Int, BOOL, Function, Equals, Not, And, Or, Implies, Iff,
                             ExactlyOne, Solver, TRUE, FALSE, FunctionType, Plus, Ite)
from pysmt.typing import INT as SMT_INT_TYPE
from pysmt.typing import BOOL as SMT_BOOL_TYPE
from pysmt.fnode import FNode
from typing import Callable, List, Dict, Any, Tuple, Literal

# --- Global Python Omega for SMT Context ---
_Omega_py_r5_2: int = 0

# --- Symbolic Core AVCA Definitions (adapted from AVCA Core DraftV4 Appendix B) ---
def create_symbolic_avc_val_r5_2(name_prefix: str) -> Dict[str, Any]:
    """Creates symbolic components for an AVCVal."""
    return {
        "is_zero": Symbol(f"{name_prefix}_is_zero_r52", SMT_BOOL_TYPE),
        "is_areo": Symbol(f"{name_prefix}_is_areo_r52", SMT_BOOL_TYPE),
        "is_finite": Symbol(f"{name_prefix}_is_finite_r52", SMT_BOOL_TYPE),
        "val": Symbol(f"{name_prefix}_val_r52", SMT_INT_TYPE),
        "name": name_prefix # Store original name for reference
    }

def get_base_avc_constraints_r5_2(avc_repr: Dict[str, FNode], omega_smt_node: FNode) -> List[FNode]:
    """Basic constraints for a well-formed symbolic AVCVal for a given Omega."""
    constraints = [
        ExactlyOne(avc_repr["is_zero"], avc_repr["is_areo"], avc_repr["is_finite"]),
        Implies(avc_repr["is_finite"], And(avc_repr["val"] > Int(0), avc_repr["val"] < omega_smt_node)),
        Implies(avc_repr["is_zero"], Equals(avc_repr["val"], Int(0))), 
        Implies(avc_repr["is_areo"], Equals(avc_repr["val"], omega_smt_node)) 
    ]
    global _Omega_py_r5_2
    if _Omega_py_r5_2 == 1: 
        constraints.append(Not(avc_repr["is_finite"])) 
    return constraints

def avc_add_smt_logic_r5_2(a: Dict[str, FNode], b: Dict[str, FNode],
                           res: Dict[str, FNode], omega_smt_node: FNode) -> FNode:
    """
    SMT Logic for Core AVCA-Ω avc_add (⊕_v1.1: DFI overflow to AREO_UNIO object).
    """
    a_is_unio = Or(a["is_zero"], a["is_areo"])
    b_is_unio = Or(b["is_zero"], b["is_areo"])

    res_becomes_a_state = And(Iff(res["is_zero"], a["is_zero"]),
                              Iff(res["is_areo"], a["is_areo"]),
                              Iff(res["is_finite"], a["is_finite"]),
                              Equals(res["val"], a["val"]))
    
    res_becomes_b_state = And(Iff(res["is_zero"], b["is_zero"]),
                              Iff(res["is_areo"], b["is_areo"]),
                              Iff(res["is_finite"], b["is_finite"]),
                              Equals(res["val"], b["val"]))

    case1_a_is_unio = Implies(a_is_unio, res_becomes_b_state)
    case2_b_is_unio_a_is_dfi = Implies(And(Not(a_is_unio), b_is_unio), res_becomes_a_state)
    
    cond_both_are_dfi = And(a["is_finite"], b["is_finite"])
    symbolic_sum_val = Plus(a["val"], b["val"]) 

    res_is_dfi_sum_state = And(Not(res["is_zero"]), Not(res["is_areo"]), res["is_finite"],
                               Equals(res["val"], symbolic_sum_val))
    
    res_is_areo_unio_state = And(Not(res["is_zero"]), res["is_areo"], Not(res["is_finite"]),
                                 Equals(res["val"], omega_smt_node))

    case3_dfi_dfi_logic = Implies(
        cond_both_are_dfi,
        Ite(symbolic_sum_val < omega_smt_node,   
            res_is_dfi_sum_state,                
            res_is_areo_unio_state               
        )
    )
    return And(case1_a_is_unio, case2_b_is_unio_a_is_dfi, case3_dfi_dfi_logic)

# --- SMT Test Function for Inverse Multiplicity ---
def test_dfi_inverse_multiplicity_smt(omega_val_py: int,
                                      condition_on_a_val_str: str,
                                      condition_on_a_val_formula_func: Callable[[Dict[str, FNode]], FNode],
                                      expect_sat: bool): 
    """
    Tests for DFI inverse multiplicity using SMT.
    Asserts: exists DFI a, DFI x, DFI x_prime such that:
             x.val != x_prime.val (their DFI values are different)
             condition_on_a_val_formula (generated by func) holds for 'a'
             a + x ~ Unio
             a + x_prime ~ Unio
    """
    global _Omega_py_r5_2
    _Omega_py_r5_2 = omega_val_py

    print(f"\n--- SMT DFI Inverse Multiplicity Test for Ω = {omega_val_py} ---")
    print(f"Condition on 'a': {condition_on_a_val_str}")
    print(f"Expecting SAT (i.e., multiplicity witness exists): {expect_sat}")

    omega_smt_node = Int(omega_val_py)

    # Symbolic AVCA values for the existential query
    # Using a consistent naming convention for 'a' that the lambda can refer to if needed,
    # but the lambda receives the 'a' dict directly.
    a_sym = create_symbolic_avc_val_r5_2("a_existential") 
    x_sym = create_symbolic_avc_val_r5_2("x_inv1")
    x_prime_sym = create_symbolic_avc_val_r5_2("x_inv2")
    
    res1_sym = create_symbolic_avc_val_r5_2("res_a_x") 
    res2_sym = create_symbolic_avc_val_r5_2("res_a_xprime")

    assertions = []
    assertions.extend(get_base_avc_constraints_r5_2(a_sym, omega_smt_node))
    assertions.extend(get_base_avc_constraints_r5_2(x_sym, omega_smt_node))
    assertions.extend(get_base_avc_constraints_r5_2(x_prime_sym, omega_smt_node))
    assertions.extend(get_base_avc_constraints_r5_2(res1_sym, omega_smt_node))
    assertions.extend(get_base_avc_constraints_r5_2(res2_sym, omega_smt_node))

    # Assert a, x, x_prime are DFI
    assertions.append(a_sym["is_finite"])
    assertions.append(x_sym["is_finite"])
    assertions.append(x_prime_sym["is_finite"])
    
    # Apply specific condition on a_sym (e.g., a_sym["val"] == 1)
    assertions.append(condition_on_a_val_formula_func(a_sym)) 
    
    # Assert x and x_prime are distinct DFI elements (their values are different)
    assertions.append(Not(Equals(x_sym["val"], x_prime_sym["val"]))) 
    
    # Assert a + x results in Unio
    assertions.append(avc_add_smt_logic_r5_2(a_sym, x_sym, res1_sym, omega_smt_node))
    assertions.append(Or(res1_sym["is_zero"], res1_sym["is_areo"])) # res1 is algebraic Unio

    # Assert a + x_prime results in Unio
    assertions.append(avc_add_smt_logic_r5_2(a_sym, x_prime_sym, res2_sym, omega_smt_node))
    assertions.append(Or(res2_sym["is_zero"], res2_sym["is_areo"])) # res2 is algebraic Unio

    print("\nSolving with Z3...")
    with Solver(name="z3") as s:
        for an_assertion in assertions:
            s.add_assertion(an_assertion)
        
        result = s.solve()

        if result:
            print("Status: SAT")
            if expect_sat:
                print("  This is EXPECTED. Multiple distinct DFI inverses found for 'a' under the conditions.")
                model = s.get_model()
                print("  Witness (example):")
                print(f"    a.val = {model.get_value(a_sym['val'])}") 
                print(f"    x.val (first inverse) = {model.get_value(x_sym['val'])}")
                print(f"    x_prime.val (second distinct inverse) = {model.get_value(x_prime_sym['val'])}")
            else:
                print("  This is UNEXPECTED. Found multiple inverses where uniqueness was expected.")
                model = s.get_model()
                print("  Erroneous Witness (example):")
                print(f"    a.val = {model.get_value(a_sym['val'])}")
                print(f"    x.val = {model.get_value(x_sym['val'])}")
                print(f"    x_prime.val = {model.get_value(x_prime_sym['val'])}")
        else:
            print("Status: UNSAT")
            if not expect_sat:
                print("  This is EXPECTED. No multiple distinct DFI inverses found under these conditions (implies uniqueness).")
            else:
                print("  This is UNEXPECTED. Expected to find multiple inverses but found none (implies no such 'a' exists under the conditions, or a problem with the SMT logic if 'a' should exist).")
    print("-" * 70)

# --- Main Execution ---
if __name__ == "__main__":
    print("====== Script R5.2: SMT Confirmation of DFI Additive Inverse Multiplicity (for ⊕_v1.1) ======")
    print("\n--- Testing Scenarios for Inverse Multiplicity ---")
    
    # Case 1: Ω = 2 (DFI = {1})
    # For a.val = 1, expect no multiple distinct DFI inverses (expect UNSAT for multiplicity query).
    # The DFI {1} does not contain two distinct elements x, x_prime.
    # The SMT solver should determine this from the constraints on x and x_prime being DFI
    # and x.val != x_prime.val, in conjunction with their range (1 <= val < 2 for DFI).
    print("\nTesting Ω = 2")
    test_dfi_inverse_multiplicity_smt(
        omega_val_py=2,
        condition_on_a_val_str="a.val = 1",
        condition_on_a_val_formula_func=lambda a_s: Equals(a_s["val"], Int(1)),
        expect_sat=False 
    )

    # Case 2: Ω = 3 (DFI = {1, 2})
    # For a.val = 2 (which implies a.val >= 2), expect multiplicity (SAT).
    # From R5.1, for Ω=3, a=2, inverses are {1, 2}. So x=1, x_prime=2 is a witness.
    print("\nTesting Ω = 3")
    test_dfi_inverse_multiplicity_smt(
        omega_val_py=3,
        condition_on_a_val_str="a.val = 2",
        condition_on_a_val_formula_func=lambda a_s: Equals(a_s["val"], Int(2)),
        expect_sat=True
    )

    # Case 3: Ω = 4 (DFI = {1, 2, 3})
    print("\nTesting Ω = 4")
    # For a.val = 2, expect multiplicity. (R5.1 showed inverses {2,3} for a=2, Ω=4)
    test_dfi_inverse_multiplicity_smt(
        omega_val_py=4,
        condition_on_a_val_str="a.val = 2",
        condition_on_a_val_formula_func=lambda a_s: Equals(a_s["val"], Int(2)),
        expect_sat=True
    )
    # For a.val = 3, expect multiplicity. (R5.1 showed inverses {1,2,3} for a=3, Ω=4)
    test_dfi_inverse_multiplicity_smt(
        omega_val_py=4,
        condition_on_a_val_str="a.val = 3",
        condition_on_a_val_formula_func=lambda a_s: Equals(a_s["val"], Int(3)),
        expect_sat=True
    )
    
    # Case 4: Ω = 5 (DFI = {1, 2, 3, 4})
    print("\nTesting Ω = 5")
    # Test for a.val = 1 (expect UNSAT for multiplicity, as only inverse is Fp(4) from R5.1)
    test_dfi_inverse_multiplicity_smt(
        omega_val_py=5,
        condition_on_a_val_str="a.val = 1",
        condition_on_a_val_formula_func=lambda a_s: Equals(a_s["val"], Int(1)),
        expect_sat=False
    )
    # Test for a.val = 2 (expect SAT for multiplicity. R5.1 showed inverses {3,4} for a=2, Ω=5)
    test_dfi_inverse_multiplicity_smt(
        omega_val_py=5,
        condition_on_a_val_str="a.val = 2",
        condition_on_a_val_formula_func=lambda a_s: Equals(a_s["val"], Int(2)),
        expect_sat=True
    )

    print("\n====== R5.2 Script Finished ======")